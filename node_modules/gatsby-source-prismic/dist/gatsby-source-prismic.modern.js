import{useReducer as e,useMemo as t,useEffect as i,useCallback as a,createContext as r,createElement as n,useContext as s}from"react";import{set as o}from"es-cookie";import{getApi as c,previewCookie as l}from"prismic-javascript";import{camelCase as d}from"camel-case";import{string as p,optional as m,record as u,object as g,defaulted as y,func as w,array as h,union as f,boolean as v,enums as P,number as I,empty as b,coerce as D,assert as S}from"superstruct";import{pascalCase as _,pascalCaseTransformMerge as T}from"pascal-case";import{Link as E,RichText as N}from"prismic-dom";import{buildImgixFixed as k,buildImgixFluid as O}from"gatsby-plugin-imgix";import{v5 as x}from"uuid";import L from"md5";import R from"lodash.pick";import A from"lodash.omit";import $ from"lodash.isplainobject";import{navigate as B}from"gatsby";const C={repositoryName:p(),accessToken:m(p()),releaseID:m(p()),schemas:u(p(),g()),linkResolver:y(w(),()=>()=>()=>{}),htmlSerializer:y(w(),()=>()=>()=>{}),fetchLinks:y(h(p()),[]),lang:y(p(),"*"),typePathsFilenamePrefix:y(p(),"prismic-typepaths---"),prismicToolbar:y(f([v(),P(["legacy"])]),!1),imageImgixParams:y(u(p(),m(f([p(),I(),v()]))),{auto:"format,compress",fit:"max",q:50}),imagePlaceholderImgixParams:y(u(p(),m(f([p(),I(),v()]))),{w:100,blur:15,q:20}),plugins:y(b(h()),[])},G=(g({...C,shouldDownloadImage:y(m(w()),()=>()=>!1)}),g({...C,pathResolver:m(w()),schemasDigest:p()})),W=async(e,t)=>{const i={},a=Object.keys(t);return await Promise.all(a.map(async a=>{i[a]=await e(t[a],a)})),i},j=e=>_("Prismic "+e,{transform:T}),F="undefined"!=typeof window,M=e=>e.displayName||e.name||"Component",U=["alt","copyright","dimensions","url"],z=async(e,t)=>await c(`https://${e}.prismic.io/api/v2`,{accessToken:t});var V,J,q,H;!function(e){e.Any="Any",e.Document="Document",e.Media="Media",e.Web="Web"}(V||(V={})),function(e){e.Boolean="Boolean",e.Color="Color",e.Date="Date",e.Embed="Embed",e.GeoPoint="GeoPoint",e.Group="Group",e.Image="Image",e.Link="Link",e.Number="Number",e.Select="Select",e.Slice="Slice",e.Slices="Slices",e.StructuredText="StructuredText",e.Text="Text",e.Timestamp="Timestamp",e.UID="UID",e.AlternateLanguages="AlternateLanguages"}(J||(J={})),function(e){e.ID="ID",e.Boolean="Boolean",e.String="String",e.Float="Float",e.Date="Date",e.JSON="JSON",e.Link="PrismicLinkType",e.Image="PrismicImageType",e.ImageThumbnail="PrismicImageThumbnailType",e.ImageThumbnails="PrismicImageThumbnailsType",e.Embed="PrismicEmbedType",e.GeoPoint="PrismicGeoPointType",e.StructuredText="PrismicStructuredTextType",e.AllDocumentTypes="PrismicAllDocumentTypes",e.Group="Group",e.Slices="Slices",e.AlternateLanguages="AlternateLanguages"}(q||(q={})),function(e){e.List="list",e.Grid="grid"}(H||(H={}));const Q=async(e,t,i,a,r)=>{const{createNodeId:n,createNode:s,createContentDigest:o,typePaths:c,normalizeStructuredTextField:l,normalizeLinkField:d,normalizeImageField:p,normalizeSlicesField:m}=r;switch(((e,t)=>{const i=JSON.stringify(e),a=t.find(e=>JSON.stringify(e.path)===i);if(a)return/^\[.*GroupType\]$/.test(a.type)?q.Group:/^\[.*SlicesType\]$/.test(a.type)?q.Slices:a.type})([...i,e],c)){case q.Image:{const n=R(t,U),s=A(t,U);return{...await p(e,n,i,a,r),thumbnails:await W(async t=>await p(e,t,i,a,r),s)}}case q.StructuredText:return await l(e,t,i,a,r);case q.Link:return await d(e,t,i,a,r);case q.Group:return await K(t,[...i,e],a,r);case q.Slices:{const c=await Promise.all(t.map(async(t,c)=>{var l;const d=n(`${a.type} ${a.id} ${e} ${c}`),p=await Y(t.primary,[...i,e,t.slice_type,"primary"],a,r),m=await K(t.items,[...i,e,t.slice_type,"items"],a,r),u={id:d,slice_type:t.slice_type,slice_label:null!==(l=t.slice_label)&&void 0!==l?l:void 0,primary:p,items:m,internal:{type:j(`${a.type} ${e} ${t.slice_type}`),contentDigest:o(t)}};return s(u),u.id}));return await m(e,c,[...i,e],a,r)}case q.AlternateLanguages:return await Promise.all(t.map(async t=>await d(e,{...t,link_type:V.Document},i,a,r)));default:return t}},Y=(e={},t,i,a)=>W((e,r)=>Q(r,e,t,i,a),e),K=(e=[],t,i,a)=>Promise.all(e.map(e=>Y(e,t,i,a))),X=async(e,t)=>{const{createNode:i,createContentDigest:a,createNodeId:r,pluginOptions:n}=t,{linkResolver:s}=n;let o=void 0;s&&(o=s({node:e}));const c=r(`${e.type} ${e.id}`),l=o?o(e):void 0,d=await Y(e.data,[e.type,"data"],e,t),p=await Q("alternate_languages",e.alternate_languages,[e.type],e,t),m={...e,id:c,prismicId:e.id,data:d,dataString:JSON.stringify(e.data),dataRaw:e.data,alternate_languages:p,url:l,internal:{type:j(e.type),contentDigest:a(e)},_previewable:e.id};return i(m),m.id},Z=async(e,t,i,a,r)=>{const{pluginOptions:n}=r,s=t.url;if(!s)return t;const o=k({url:s,sourceWidth:t.dimensions.width,sourceHeight:t.dimensions.height,args:{imgixParams:n.imageImgixParams,placeholderImgixParams:n.imagePlaceholderImgixParams}}),c=O({url:s,sourceWidth:t.dimensions.width,sourceHeight:t.dimensions.height,args:{imgixParams:n.imageImgixParams,placeholderImgixParams:n.imagePlaceholderImgixParams}});return{...t,fixed:o,fluid:c}},ee=async(e,t,i,a,r)=>{const{createNodeId:n,pluginOptions:s,context:o}=r,{getNodeById:c}=o,{linkResolver:l}=s;let d=void 0;l&&(d=l({key:e,value:t,node:a}));const p=n(`${t.type} ${t.id}`);return t.link_type===V.Document&&t.id&&!t.isBroken&&await(async(e,t)=>{const{createNode:i,createNodeId:a,createContentDigest:r,pluginOptions:n,context:s}=t;if(e.link_type!==V.Document||!e.id||e.isBroken)return;const{hasNodeById:o}=s,{repositoryName:c,accessToken:l,fetchLinks:d}=n,p=a(`${e.type} ${e.id}`);if(o(p))return;i({id:p,internal:{type:j(e.type)+"__PLACEHOLDER",contentDigest:r(p)}});const m={};d&&(m.fetchLinks=d);const u=await z(c,l),g=await u.getByID(e.id,m);await X(g,t)})(t,r),new Proxy({...t,url:E.url(t,d),document:p,raw:t},{get:(e,i)=>"document"===i?t.link_type===V.Document&&t.id&&!t.isBroken?c(p):null:e[i]})},te=(e,t,i,a,r)=>{const{context:n}=r,{hasNodeById:s,getNodeById:o}=n;return new Proxy(t,{get:(e,t)=>{const i=e[t];if(s(i)){const e=o(i);return{...e,__typename:e.internal.type}}return i}})},ie=async(e,t,i,a,r)=>{const{pluginOptions:n}=r,{linkResolver:s,htmlSerializer:o}=n;let c=void 0;s&&(c=s({key:e,value:t,node:a}));let l=void 0;return o&&(l=o({key:e,value:t,node:a})),{html:N.asHtml(t,c,l),text:N.asText(t),raw:t}};var ae;!function(e){e.IS_NOT_PREVIEW="IS_NOT_PREVIEW",e.IS_PREVIEW="IS_PREVIEW",e.DOCUMENT_LOADED="DOCUMENT_LOADED",e.RESET="RESET"}(ae||(ae={}));const re={isPreview:void 0,isLoading:!1,previewData:void 0,path:void 0},ne=(e,t)=>{switch(t.type){case ae.IS_NOT_PREVIEW:return{...e,isPreview:!1,isLoading:!1};case ae.IS_PREVIEW:return{...e,isPreview:!0,isLoading:!0};case ae.DOCUMENT_LOADED:{if(!t.payload)return{...e,isPreview:!1,isLoading:!1};const{rootNode:i,path:a}=t.payload,r={[d(i.internal.type)]:i};return{...e,previewData:r,path:a,isPreview:!0,isLoading:!1}}case ae.RESET:return re;default:throw new Error("Invalid error")}},se=r=>{const[n,s]=e(ne,re),c=t(()=>{if(!F)return r;const e=window.__GATSBY_SOURCE_PRISMIC__[r.repositoryName];if(!e)throw new Error(`Could not find plugin context for repository: "${r.repositoryName}". Check that a gatsby-source-plugin instance exists for that repository. `);return(e=>{const t=D(e,G);return S(t,G),t})({...e.pluginOptions,schemasDigest:e.schemasDigest,schemas:{},...r})},[r]),{token:d,documentId:p}=t(()=>{var e,t;if(!F)return{};const i=new URLSearchParams(window.location.search);return{token:null!==(e=i.get("token"))&&void 0!==e?e:void 0,documentId:null!==(t=i.get("documentId"))&&void 0!==t?t:void 0}},[F?window.location.search:void 0]);i(()=>{const e=Boolean(d&&p);s({type:e?ae.IS_PREVIEW:ae.IS_NOT_PREVIEW})},[d,p]);const m=a(async()=>{var e;if(!n.isPreview||!d||!p)return;o(l,d);const t={};c.fetchLinks&&(t.fetchLinks=c.fetchLinks);const i=await z(c.repositoryName,c.accessToken),a=await i.getByID(p,t),r=await fetch(`/${c.typePathsFilenamePrefix}${c.schemasDigest}.json`,{headers:{"Content-Type":"application/json"}}),m=await r.json(),u=((e,t)=>{const i=new Map;return{createNode:e=>{i.set(e.id,e)},createNodeId:e=>x(e,"638f7a53-c567-4eca-8fc1-b23efb1cfb2b"),createContentDigest:e=>L(JSON.stringify(e)),normalizeImageField:Z,normalizeLinkField:ee,normalizeSlicesField:te,normalizeStructuredTextField:ie,typePaths:t,pluginOptions:e,context:{hasNodeById:e=>i.has(e),getNodeById:e=>i.get(e)}}})(c,m),{context:g}=u,{getNodeById:y}=g,w=y(await X(a,u)),h=null!==(e=c.pathResolver)&&void 0!==e?e:c.linkResolver,f=h?h({node:a})(a):void 0;s({type:ae.DOCUMENT_LOADED,payload:{rootNode:w,path:f}})},[n.isPreview]);return i(()=>{m()},[m]),n},oe=(e,t)=>{if($(e)){if(e._previewable===t._previewable)return t;if(e.prismicId===t.prismicId)return console.warn("Warning: Merging nested preview data using the prismicId field will be deprecated in gatsby-source-prismic v4.0.0.\n\nIf you are relying on this functionality, please update your GraphQL query to include the _previewable field on documents that should be previewable."),t;const i={};for(const a in e)i[a]=oe(e[a],t);return i}return Array.isArray(e)?e.map(e=>oe(e,t)):e},ce=({staticData:e,previewData:t,strategy:i="traverseAndReplace"})=>{if(e||t){if(!e)return t;if(!t)return e;switch(i){case"rootReplaceOrInsert":return{...e,...t};case"traverseAndReplace":default:{const i=Object.keys(t)[0];return!e.hasOwnProperty(i)||e[i]._previewable||e[i].prismicId?oe(e,t[i]):(console.warn("Warning: Merging preview data implicitly will be deprecated in gatsby-source-prismic v4.0.0.\n\nIf you are relying on this functionality, please update your GraphQL query to include the _previewable field on documents that should be previewable."),{...e,...t})}}}},le={};var de;!function(e){e[e.AddPage=0]="AddPage",e[e.EnablePreviews=1]="EnablePreviews",e[e.DisablePreviews=2]="DisablePreviews"}(de||(de={}));const pe=e=>({pages:le,enabled:!1,...e}),me=(e,t)=>{switch(t.type){case de.AddPage:return{...e,pages:{...e.pages,[t.payload.path]:t.payload.data},enabled:!0};case de.EnablePreviews:return{...e,enabled:!0};case de.DisablePreviews:return{...e,enabled:!1}}},ue=r([pe(),()=>{}]),ge=({children:t,initialPages:i=le,initialEnabled:a=!1})=>{const r=e(me,pe({pages:i,enabled:a}));return n(ue.Provider,{value:r},t)},ye=()=>s(ue),we=(e,i)=>{const a=a=>{const[r]=ye(),s=a.data,o=r.pages[a.location.pathname],c=t(()=>r.enabled?ce({staticData:s,previewData:o,strategy:null==i?void 0:i.mergeStrategy}):s,[r.enabled,s,o]);return n(e,Object.assign({},a,{data:c}))};return a.displayName=`withPreview(${M(e)})`,a},he=(e,t)=>{const a=a=>{const[,r]=ye(),{isLoading:s,isPreview:o,previewData:c,path:l}=se(t);return i(()=>{o&&c&&l&&(r({type:de.AddPage,payload:{path:l,data:c}}),B(l))},[o,c,l,r]),n(e,Object.assign({},a,{isPreview:o,isLoading:s}))};return a.displayName=`withPreviewResolver(${M(e)})`,a},fe=(e,t)=>{const i=i=>{const[a]=ye(),r=i.location.pathname;if(a.pages.hasOwnProperty(r)){const e=a.pages[r],s=e[Object.keys(e)[0]].type,o=t.templateMap[s];if(o)return n(o,Object.assign({},i));console.warn(`gatsby-source-prismic - An unpublished preview was detected, but a template component could not be found for a custom type of "${s}". Check that the templateMap option in withUnpublishedPreview includes a component for "${s}". withUnpublishedPreview will yield to the wrapped component to render.`)}return n(e,Object.assign({},i))};return i.displayName=`withUnpublishedPreview(${M(e)})`,we(i,{mergeStrategy:"rootReplaceOrInsert"})};export{ge as PreviewStoreProvider,ce as mergePrismicPreviewData,ye as usePreviewStore,se as usePrismicPreview,we as withPreview,he as withPreviewResolver,fe as withUnpublishedPreview};
//# sourceMappingURL=gatsby-source-prismic.modern.js.map
